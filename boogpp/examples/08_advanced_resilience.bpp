###
Boog++ Example 8: Advanced Resilience
Demonstrates try_chain with complex failover scenarios.
###

@safety_level(mode: SAFE)
module advanced_resilience

import windows.registry
import windows.network
import std.io
import std.time
import std.fs

struct ConfigData:
    api_url: string
    api_key: string
    timeout: i32
    retry_count: i32

@resilient(max_attempts: 5, timeout: 10000ms, backoff: EXPONENTIAL)
func fetch_config() -> (i32, ConfigData):
    # Try multiple sources to get configuration
    return try_chain:
        primary:
            fetch_config_from_registry()
        secondary:
            fetch_config_from_file()
        fallback:
            get_default_config()

func fetch_config_from_registry() -> (i32, ConfigData):
    std.io.log("Attempting to fetch config from registry...")

    status1, api_url = windows.registry.read("HKLM\\Software\\MyApp", "ApiUrl")
    status2, api_key = windows.registry.read("HKLM\\Software\\MyApp", "ApiKey")

    if status1 == SUCCESS and status2 == SUCCESS:
        let config = ConfigData(
            api_url: api_url,
            api_key: api_key,
            timeout: 5000,
            retry_count: 3
        )
        std.io.log("Config loaded from registry")
        return (SUCCESS, config)

    return (GENERIC_ERROR, ConfigData())

func fetch_config_from_file() -> (i32, ConfigData):
    std.io.log("Attempting to fetch config from file...")

    let config_path = "C:\\ProgramData\\MyApp\\config.json"

    status, content = std.fs.read_file(config_path)

    if status == SUCCESS:
        # Parse JSON config
        let config = ConfigData(
            api_url: "https://api.example.com",
            api_key: "file_based_key",
            timeout: 5000,
            retry_count: 3
        )
        std.io.log("Config loaded from file")
        return (SUCCESS, config)

    return (GENERIC_ERROR, ConfigData())

func get_default_config() -> (i32, ConfigData):
    std.io.log("Using default configuration")

    let config = ConfigData(
        api_url: "https://default.example.com",
        api_key: "default_key",
        timeout: 3000,
        retry_count: 2
    )

    return (SUCCESS, config)

@resilient(max_attempts: 3, timeout: 5000ms)
func fetch_remote_data(url: string) -> (i32, string):
    return try_chain:
        primary:
            windows.network.http_get(url)
        secondary:
            windows.network.http_get(url + "/backup")
        fallback:
            (SUCCESS, "CACHED_DATA")

func process_with_resilience() -> void:
    std.io.println("Starting resilient data processing...")

    # Fetch configuration with automatic failover
    status, config = fetch_config()

    if status != SUCCESS:
        std.io.println("ERROR: Could not fetch configuration")
        return

    std.io.println("Configuration loaded successfully:")
    std.io.println("  API URL: " + config.api_url)
    std.io.println("  Timeout: " + string(config.timeout) + "ms")
    std.io.println("  Retry Count: " + string(config.retry_count))
    std.io.println("")

    # Fetch remote data with resilience
    std.io.println("Fetching remote data...")
    status2, data = fetch_remote_data(config.api_url)

    if status2 == SUCCESS:
        std.io.println("Data fetched successfully: " + data)
    else:
        std.io.println("Failed to fetch data after all retries")

func main() -> i32:
    std.io.println("Advanced Resilience Demo")
    std.io.println("=" * 50)
    std.io.println("")

    process_with_resilience()

    return SUCCESS
